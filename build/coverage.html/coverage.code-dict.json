{"/home/travis/build/npmtest/node-npmtest-asyncawait/test.js":"/* istanbul instrument in package npmtest_asyncawait */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-asyncawait/lib.npmtest_asyncawait.js":"/* istanbul instrument in package npmtest_asyncawait */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_asyncawait = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_asyncawait = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-asyncawait/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-asyncawait && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_asyncawait */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_asyncawait\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_asyncawait.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_asyncawait.rollup.js'] =\n            local.assetsDict['/assets.npmtest_asyncawait.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_asyncawait.__dirname +\n                    '/lib.npmtest_asyncawait.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/index.js":"ï»¿var async = require('./src/async');\r\nvar await = require('./src/await');\r\n\r\nexports.async = async;\r\nexports.await = await;\r\n","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/index.js":"var Config = require('./config');\r\nvar makeAsyncFunc = require('./makeAsyncFunc');\r\n/**\r\n  * Creates a suspendable function. Suspendable functions may use the await() function\r\n  * internally to suspend execution at arbitrary points, pending the results of\r\n  * internal asynchronous operations.\r\n  * @param {Function} fn - Contains the body of the suspendable function. Calls to await()\r\n  *                        may appear inside this function.\r\n  * @returns {Function} A function of the form `(...args) --> Promise`. Any arguments\r\n  *                     passed to this function are passed through to fn. The returned\r\n  *                     promise is resolved when fn returns, or rejected if fn throws.\r\n  */\r\nvar async = makeAsyncFunc(new Config());\r\nasync.cps = async.mod('returns: none, callback: true, iterable: false');\r\nasync.thunk = async.mod('returns: thunk, callback: false, iterable: false');\r\nasync.result = async.mod('returns: result, callback: false, iterable: false');\r\nasync.iterable = async.mod('returns: promise, callback: false, iterable: true');\r\nmodule.exports = async;\r\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/config.js":"var assert = require('assert');\r\n/** A config object holds the configuration options for a variant of the async function. */\r\nvar Config = (function () {\r\n    /** Construct a new Config instance. */\r\n    function Config(options) {\r\n        /** Recognised values: 'none', 'promise', 'thunk', 'result'. */\r\n        this.returnValue = Config.PROMISE;\r\n        /** Indicates whether a callback function, if supplied, will be used to notify waiters of results. */\r\n        this.acceptsCallback = false;\r\n        /** Indicates whether the suspendable function has iterator semantics or normal semantics. */\r\n        this.isIterable = false;\r\n        /** Indicates whether top-level concurrency should be limited to a specified ceiling. */\r\n        this.maxConcurrency = null;\r\n        if (options) {\r\n            this.returnValue = options.returnValue;\r\n            this.acceptsCallback = options.acceptsCallback;\r\n            this.isIterable = options.isIterable;\r\n            this.maxConcurrency = options.maxConcurrency;\r\n        }\r\n    }\r\n    /** Checks all configuration values and throw an error if anything is invalid. */\r\n    Config.prototype.validate = function () {\r\n        var knownRetVal = [Config.PROMISE, Config.THUNK, Config.RESULT, Config.NONE].indexOf(this.returnValue) !== -1;\r\n        assert(knownRetVal, 'Unrecognised return value: ' + this.returnValue);\r\n        var hasNotifier = this.returnValue !== Config.NONE || this.acceptsCallback;\r\n        assert(hasNotifier, 'At least one notification method must be enabled.');\r\n    };\r\n    // Constants for use with returnValue and callbackArg\r\n    Config.PROMISE = 'promise';\r\n    Config.THUNK = 'thunk';\r\n    Config.RESULT = 'result';\r\n    Config.NONE = 'none';\r\n    return Config;\r\n})();\r\nmodule.exports = Config;\r\n//# sourceMappingURL=config.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/makeAsyncFunc.js":"var Fiber = require('../fibers');\r\nvar _ = require('lodash');\r\nvar Config = require('./config');\r\nvar FiberMgr = require('./fiberManager');\r\nvar RunContext = require('./runContext');\r\nvar Semaphore = require('./semaphore');\r\nvar AsyncIterator = require('./asyncIterator');\r\nvar defer = require('./defer');\r\nvar await = require('../await/index');\r\n/** Function for creating a specific variant of the async function. */\r\nfunction makeAsyncFunc(config) {\r\n    // Validate the specified configuration\r\n    config.validate();\r\n    // Create an async function tailored to the given options.\r\n    var result = function async(bodyFunc) {\r\n        // Create a semaphore for limiting top-level concurrency, if specified in options.\r\n        var semaphore = config.maxConcurrency ? new Semaphore(config.maxConcurrency) : Semaphore.unlimited;\r\n        // Choose and run the appropriate function factory based on whether the result should be iterable.\r\n        var makeFunc = config.isIterable ? makeAsyncIterator : makeAsyncNonIterator;\r\n        var result = makeFunc(bodyFunc, config, semaphore);\r\n        // Ensure the suspendable function's arity matches that of the function it wraps.\r\n        var arity = bodyFunc.length;\r\n        if (config.acceptsCallback)\r\n            ++arity;\r\n        result = makeFuncWithArity(result, arity);\r\n        return result;\r\n    };\r\n    // Add the mod() function, and return the result.\r\n    result.mod = makeModFunc(config);\r\n    return result;\r\n}\r\n/** Function for creating iterable suspendable functions. */\r\nfunction makeAsyncIterator(bodyFunc, config, semaphore) {\r\n    // Return a function that returns an iterator.\r\n    return function iterable() {\r\n        // Capture the initial arguments used to start the iterator, as an array.\r\n        var startupArgs = new Array(arguments.length + 1); // Reserve 0th arg for the yield function. \r\n        for (var i = 0, len = arguments.length; i < len; ++i)\r\n            startupArgs[i + 1] = arguments[i];\r\n        // Create a yield() function tailored for this iterator.\r\n        var yield_ = function (expr) {\r\n            // Ensure this function is executing inside a fiber.\r\n            if (!Fiber.current) {\r\n                throw new Error('await functions, yield functions, and value-returning suspendable ' +\r\n                    'functions may only be called from inside a suspendable function. ');\r\n            }\r\n            // Notify waiters of the next result, then suspend the iterator.\r\n            if (runContext.callback)\r\n                runContext.callback(null, { value: expr, done: false });\r\n            if (runContext.resolver)\r\n                runContext.resolver.resolve({ value: expr, done: false });\r\n            Fiber.yield();\r\n        };\r\n        // Insert the yield function as the first argument when starting the iterator.\r\n        startupArgs[0] = yield_;\r\n        // Create the iterator.\r\n        var runContext = new RunContext(bodyFunc, this, startupArgs);\r\n        var iterator = new AsyncIterator(runContext, semaphore, config.returnValue, config.acceptsCallback);\r\n        // Wrap the given bodyFunc to properly complete the iteration.\r\n        runContext.wrapped = function () {\r\n            var len = arguments.length, args = new Array(len);\r\n            for (var i = 0; i < len; ++i)\r\n                args[i] = arguments[i];\r\n            bodyFunc.apply(this, args);\r\n            iterator.destroy();\r\n            return { done: true };\r\n        };\r\n        // Return the iterator.\r\n        return iterator;\r\n    };\r\n}\r\n/** Function for creating non-iterable suspendable functions. */\r\nfunction makeAsyncNonIterator(bodyFunc, config, semaphore) {\r\n    // Return a function that executes fn in a fiber and returns a promise of fn's result.\r\n    return function nonIterable() {\r\n        // Get all the arguments passed in, as an array.\r\n        var argsAsArray = new Array(arguments.length);\r\n        for (var i = 0; i < argsAsArray.length; ++i)\r\n            argsAsArray[i] = arguments[i];\r\n        // Remove concurrency restrictions for nested calls, to avoid race conditions.\r\n        if (FiberMgr.isExecutingInFiber())\r\n            this._semaphore = Semaphore.unlimited;\r\n        // Configure the run context.\r\n        var runContext = new RunContext(bodyFunc, this, argsAsArray, function () { return semaphore.leave(); });\r\n        if (config.returnValue !== Config.NONE) {\r\n            var resolver = defer();\r\n            runContext.resolver = resolver;\r\n        }\r\n        if (config.acceptsCallback && argsAsArray.length && _.isFunction(argsAsArray[argsAsArray.length - 1])) {\r\n            var callback = argsAsArray.pop();\r\n            runContext.callback = callback;\r\n        }\r\n        // Execute bodyFunc to completion in a coroutine. For thunks, this is a lazy operation.\r\n        if (config.returnValue === Config.THUNK) {\r\n            var thunk = function (done) {\r\n                if (done)\r\n                    resolver.promise.then(function (val) { return done(null, val); }, function (err) { return done(err); });\r\n                semaphore.enter(function () { return FiberMgr.create().run(runContext); });\r\n            };\r\n        }\r\n        else {\r\n            semaphore.enter(function () { return FiberMgr.create().run(runContext); });\r\n        }\r\n        // Return the appropriate value.\r\n        switch (config.returnValue) {\r\n            case Config.PROMISE: return resolver.promise;\r\n            case Config.THUNK: return thunk;\r\n            case Config.RESULT: return await(resolver.promise);\r\n            case Config.NONE: return;\r\n        }\r\n    };\r\n}\r\n/** Returns a function that directly proxies the given function, whilst reporting the given arity. */\r\nfunction makeFuncWithArity(fn, arity) {\r\n    // Need to handle each arity individually, but the body never changes.\r\n    switch (arity) {\r\n        case 0: return function f0() { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 1: return function f1(a) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 2: return function f2(a, b) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 3: return function f3(a, b, c) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 4: return function f4(a, b, c, d) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 5: return function f5(a, b, c, d, e) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 6: return function f6(a, b, c, d, e, f) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 7: return function f7(a, b, c, d, e, f, g) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 8: return function f8(a, b, c, d, e, f, g, h) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        case 9: return function f9(a, b, c, d, e, f, g, h, _i) { var i, l = arguments.length, r = new Array(l); for (i = 0; i < l; ++i)\r\n            r[i] = arguments[i]; return fn.apply(this, r); };\r\n        default: return fn; // Bail out if arity is crazy high.\r\n    }\r\n}\r\nfunction makeModFunc(config) {\r\n    return function (options, maxConcurrency) {\r\n        if (_.isString(options)) {\r\n            // This way of specifying options is useful for TypeScript users, as they get better type information.\r\n            // JavaScript users can use this too, but providing an options hash is more useful in that case. \r\n            var rt, cb, it;\r\n            switch (options) {\r\n                case 'returns: promise, callback: false, iterable: false':\r\n                    rt = 'promise';\r\n                    cb = false;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: thunk, callback: false, iterable: false':\r\n                    rt = 'thunk';\r\n                    cb = false;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: result, callback: false, iterable: false':\r\n                    rt = 'result';\r\n                    cb = false;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: promise, callback: true, iterable: false':\r\n                    rt = 'promise';\r\n                    cb = true;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: thunk, callback: true, iterable: false':\r\n                    rt = 'thunk';\r\n                    cb = true;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: result, callback: true, iterable: false':\r\n                    rt = 'result';\r\n                    cb = true;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: none, callback: true, iterable: false':\r\n                    rt = 'none';\r\n                    cb = true;\r\n                    it = false;\r\n                    break;\r\n                case 'returns: promise, callback: false, iterable: true':\r\n                    rt = 'promise';\r\n                    cb = false;\r\n                    it = true;\r\n                    break;\r\n                case 'returns: thunk, callback: false, iterable: true':\r\n                    rt = 'thunk';\r\n                    cb = false;\r\n                    it = true;\r\n                    break;\r\n                case 'returns: result, callback: false, iterable: true':\r\n                    rt = 'result';\r\n                    cb = false;\r\n                    it = true;\r\n                    break;\r\n                case 'returns: promise, callback: true, iterable: true':\r\n                    rt = 'promise';\r\n                    cb = true;\r\n                    it = true;\r\n                    break;\r\n                case 'returns: thunk, callback: true, iterable: true':\r\n                    rt = 'thunk';\r\n                    cb = true;\r\n                    it = true;\r\n                    break;\r\n                case 'returns: result, callback: true, iterable: true':\r\n                    rt = 'result';\r\n                    cb = true;\r\n                    it = true;\r\n                    break;\r\n                case 'returns: none, callback: true, iterable: true':\r\n                    rt = 'none';\r\n                    cb = true;\r\n                    it = true;\r\n                    break;\r\n            }\r\n            options = { returnValue: rt, acceptsCallback: cb, isIterable: it, maxConcurrency: maxConcurrency };\r\n        }\r\n        var newConfig = new Config(_.defaults({}, options, config));\r\n        return makeAsyncFunc(newConfig);\r\n    };\r\n}\r\nmodule.exports = makeAsyncFunc;\r\n//# sourceMappingURL=makeAsyncFunc.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/fibers.js":"var Fiber = require('fibers');\r\n// HOTFIX for node-fibers problem.\r\n// I have not prepared a repro unit test yet. In the meanwhile,\r\n// here is the gist of the problem:\r\n// A problem can occur if a node.js process has a node_modules tree that\r\n// contains multiple copies of node-fibers, whether the same version or not.\r\n// For instance, a project depends on two top-level modules which each\r\n// depend on node-fibers, such that 'npm install' installs two copies of\r\n// node-fibers. Furthermore, both of these copies are required() during execution.\r\n// In this scenario, the expected control flow of the process can be corrupted.\r\n// In one observed case, resuming a suspended fiber actually transfers control\r\n// to the code encapsulated in a completely different fiber.\r\n// The problem vanishes if we ensure that only one instance of node-fibers gets\r\n// used throughout the process. The following lines do this by caching a\r\n// node-fibers instance globally on first require(), and reusing that instance\r\n// for all subsequent require()s.\r\n// NB: This is a workaround, not a complete fix! If modules other than asyncawait\r\n// use node-fibers, then the process may still end up using multiple instances of\r\n// node-fibers during execution. This needs investigating in node-fibers itself.\r\n// I intend to create a cut-down repro and raise an issue in the node-fibers project.\r\nif (!global.asyncawait)\r\n    global.asyncawait = {};\r\nif (!global.asyncawait.Fiber)\r\n    global.asyncawait.Fiber = Fiber;\r\nvar result = global.asyncawait.Fiber;\r\nmodule.exports = result;\r\n//# sourceMappingURL=fibers.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/fiberManager.js":"var Fiber = require('../fibers');\r\n/** Helpers for Fiber management. */\r\nvar FiberManager;\r\n(function (FiberManager) {\r\n    /** Returns true if the current execution context is within a fiber. */\r\n    function isExecutingInFiber() {\r\n        return !!Fiber.current;\r\n    }\r\n    FiberManager.isExecutingInFiber = isExecutingInFiber;\r\n    /** Creates and returns a new fiber in which an arbitrary function may be executed. */\r\n    function create() {\r\n        return Fiber(runInFiber);\r\n    }\r\n    FiberManager.create = create;\r\n})(FiberManager || (FiberManager = {}));\r\n/**\r\n * The runInFiber() function provides the prolog/epilog wrapper code for running a function inside\r\n * a fiber. The runInFiber() function accepts a RunContext instance, and calls the wrapped function\r\n * specified there. The final return/throw value of the wrapped function is used to notify the\r\n * promise resolver and/or callback specified in the RunContext. This function must take all its\r\n * information in a single argument because it is called via Fiber#run(), which accepts one argument.\r\n * NB: Since try/catch/finally prevents V8 optimisations, the function is split into several parts.\r\n */\r\nfunction runInFiber(runCtx) {\r\n    try {\r\n        tryBlock(runCtx);\r\n    }\r\n    catch (err) {\r\n        catchBlock(runCtx, err);\r\n    }\r\n    finally {\r\n        finallyBlock(runCtx);\r\n    }\r\n}\r\nfunction tryBlock(runCtx) {\r\n    // Maintain an accurate count of currently active fibers, for pool management.\r\n    adjustFiberCount(+1);\r\n    // Call the wrapped function. It may be suspended several times (at await and/or yield calls).\r\n    var result = runCtx.wrapped.apply(runCtx.thisArg, runCtx.argsAsArray);\r\n    // The wrapped function returned normally. Notify any waiters.\r\n    if (runCtx.callback)\r\n        runCtx.callback(null, result);\r\n    if (runCtx.resolver)\r\n        runCtx.resolver.resolve(result);\r\n}\r\nfunction catchBlock(runCtx, err) {\r\n    // The wrapped function threw an exception. Notify any waiters.\r\n    if (runCtx.callback)\r\n        runCtx.callback(err);\r\n    if (runCtx.resolver)\r\n        runCtx.resolver.reject(err);\r\n}\r\nfunction finallyBlock(runCtx) {\r\n    // Maintain an accurate count of currently active fibers, for pool management.\r\n    adjustFiberCount(-1);\r\n    // Execute the done() callback, if provided.\r\n    if (runCtx.done)\r\n        runCtx.done();\r\n}\r\n/**\r\n * The following functionality prevents memory leaks in node-fibers by actively managing Fiber.poolSize.\r\n * For more information, see https://github.com/laverdet/node-fibers/issues/169.\r\n */\r\nfunction adjustFiberCount(delta) {\r\n    activeFiberCount += delta;\r\n    if (activeFiberCount >= fiberPoolSize) {\r\n        fiberPoolSize += 100;\r\n        Fiber.poolSize = fiberPoolSize;\r\n    }\r\n}\r\nvar fiberPoolSize = Fiber.poolSize;\r\nvar activeFiberCount = 0;\r\nmodule.exports = FiberManager;\r\n//# sourceMappingURL=fiberManager.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/runContext.js":"/**\r\n * This class is used to pass all required contextual information to the runInFiber()\r\n * function as a single argument. runInFiber() can only accept a single argument because\r\n * it is invoked via Fiber#run(), which can only pass through a single argument.\r\n */\r\nvar RunContext = (function () {\r\n    /** Construct a new RunContext instance. */\r\n    function RunContext(wrapped, thisArg, argsAsArray, done) {\r\n        /** Optional promise resolver for notifying the wrapped function's return/throw value. */\r\n        this.resolver = null;\r\n        /** Optional callback for notifying the wrapped function's return/throw value. */\r\n        this.callback = null;\r\n        this.wrapped = wrapped;\r\n        this.thisArg = thisArg;\r\n        this.argsAsArray = argsAsArray;\r\n        this.done = done;\r\n    }\r\n    return RunContext;\r\n})();\r\nmodule.exports = RunContext;\r\n//# sourceMappingURL=runContext.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/semaphore.js":"/** A simple abstraction for limiting concurrent function calls to a specific upper bound. */\r\nvar Semaphore = (function () {\r\n    function Semaphore(n) {\r\n        this.n = n;\r\n        this._queued = [];\r\n        this._avail = n;\r\n    }\r\n    Semaphore.prototype.enter = function (fn) {\r\n        if (this._avail > 0) {\r\n            --this._avail;\r\n            fn();\r\n        }\r\n        else {\r\n            this._queued.push(fn);\r\n        }\r\n    };\r\n    Semaphore.prototype.leave = function () {\r\n        if (this._queued.length > 0) {\r\n            var fn = this._queued.pop();\r\n            fn();\r\n        }\r\n        else {\r\n            ++this._avail;\r\n        }\r\n    };\r\n    Semaphore.unlimited = new Semaphore(10000000);\r\n    return Semaphore;\r\n})();\r\nmodule.exports = Semaphore;\r\n//# sourceMappingURL=semaphore.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/asyncIterator.js":"var FiberMgr = require('./fiberManager');\r\nvar Semaphore = require('./semaphore');\r\nvar Config = require('./config');\r\nvar defer = require('./defer');\r\nvar await = require('../await/index');\r\n/**\r\n * Asynchronous analogue to an ES6 Iterator. Rather than return each value/done\r\n * result synchronously, the next() function notifies a promise and/or callback\r\n * when the next result is ready.\r\n */\r\nvar AsyncIterator = (function () {\r\n    /** Construct a new AsyncIterator instance. This will create a fiber. */\r\n    function AsyncIterator(runContext, semaphore, returnValue, acceptsCallback) {\r\n        this._runContext = runContext;\r\n        this._semaphore = semaphore;\r\n        this._fiber = FiberMgr.create();\r\n        this._returnValue = returnValue;\r\n        this._acceptsCallback = acceptsCallback;\r\n    }\r\n    /** Fetch the next result from the iterator. */\r\n    AsyncIterator.prototype.next = function (callback) {\r\n        var _this = this;\r\n        // Configure the run context.\r\n        if (this._acceptsCallback) {\r\n            this._runContext.callback = callback; // May be null, in which case it won't be used.\r\n        }\r\n        if (this._returnValue !== Config.NONE) {\r\n            var resolver = defer();\r\n            this._runContext.resolver = resolver;\r\n        }\r\n        // Remove concurrency restrictions for nested calls, to avoid race conditions.\r\n        if (FiberMgr.isExecutingInFiber())\r\n            this._semaphore = Semaphore.unlimited;\r\n        // Run the fiber until it either yields a value or completes. For thunks, this is a lazy operation.\r\n        if (this._returnValue === Config.THUNK) {\r\n            var thunk = function (done) {\r\n                if (done)\r\n                    resolver.promise.then(function (val) { return done(null, val); }, function (err) { return done(err); });\r\n                _this._semaphore.enter(function () { return _this._fiber.run(_this._runContext); });\r\n                _this._runContext.done = function () { return _this._semaphore.leave(); };\r\n            };\r\n        }\r\n        else {\r\n            this._semaphore.enter(function () { return _this._fiber.run(_this._runContext); });\r\n            this._runContext.done = function () { return _this._semaphore.leave(); };\r\n        }\r\n        // Return the appropriate value.\r\n        switch (this._returnValue) {\r\n            case Config.PROMISE: return resolver.promise;\r\n            case Config.THUNK: return thunk;\r\n            case Config.RESULT: return await(resolver.promise);\r\n            case Config.NONE: return;\r\n        }\r\n    };\r\n    /** Enumerate the entire iterator, calling callback with each result. */\r\n    AsyncIterator.prototype.forEach = function (callback, doneCallback) {\r\n        var _this = this;\r\n        // Create a function that calls next() in an asynchronous loop until the iteration is complete.\r\n        var run, runCtx = this._runContext;\r\n        if (this._returnValue === Config.RESULT)\r\n            run = function () { return stepAwaited(function () { return _this.next(); }); };\r\n        else if (this._returnValue === Config.THUNK)\r\n            run = function () { return _this.next()(stepCallback); };\r\n        else if (this._acceptsCallback)\r\n            run = function () { return _this.next(stepCallback); };\r\n        else\r\n            run = function () { return _this.next().then(stepResolved, endOfIteration); };\r\n        // Configure the resolver and callback to be invoked at the end of the iteration.\r\n        if (this._returnValue === Config.PROMISE || this._returnValue === Config.THUNK) {\r\n            var doneResolver = defer();\r\n        }\r\n        if (!this._acceptsCallback)\r\n            doneCallback = null;\r\n        // Execute the entire iteration. For thunks, this is a lazy operation.\r\n        if (this._returnValue === Config.THUNK) {\r\n            var thunk = function (done) {\r\n                if (done)\r\n                    doneResolver.promise.then(function (val) { return done(null, val); }, function (err) { return done(err); });\r\n                run();\r\n            };\r\n        }\r\n        else {\r\n            run();\r\n        }\r\n        // Return the appropriate value.\r\n        switch (this._returnValue) {\r\n            case Config.PROMISE: return doneResolver.promise;\r\n            case Config.THUNK: return thunk;\r\n            case Config.RESULT: return undefined;\r\n            case Config.NONE: return undefined;\r\n        }\r\n        // These functions handle stepping through and finalising the iteration.\r\n        function stepAwaited(next) {\r\n            try {\r\n                while (true) {\r\n                    var item = next();\r\n                    if (item.done)\r\n                        return endOfIteration();\r\n                    callback(item.value);\r\n                }\r\n            }\r\n            catch (err) {\r\n                endOfIteration(err);\r\n                throw err;\r\n            }\r\n        }\r\n        function stepCallback(err, result) {\r\n            if (err || result.done)\r\n                return endOfIteration(err);\r\n            callback(result.value);\r\n            setImmediate(run);\r\n        }\r\n        function stepResolved(result) {\r\n            if (result.done)\r\n                return endOfIteration();\r\n            callback(result.value);\r\n            setImmediate(run);\r\n        }\r\n        function endOfIteration(err) {\r\n            if (doneCallback)\r\n                err ? doneCallback(err) : doneCallback();\r\n            if (doneResolver) {\r\n                if (FiberMgr.isExecutingInFiber()) {\r\n                    runCtx.resolver = doneResolver; // FiberManager will handle it\r\n                }\r\n                else {\r\n                    err ? doneResolver.reject(err) : doneResolver.resolve(null);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /** Release resources associated with this object (i.e., the fiber). */\r\n    AsyncIterator.prototype.destroy = function () {\r\n        this._fiber = null;\r\n    };\r\n    return AsyncIterator;\r\n})();\r\nmodule.exports = AsyncIterator;\r\n//# sourceMappingURL=asyncIterator.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/async/defer.js":"var Promise = require('bluebird');\r\n/** Equivalent to Promise.defer() from bluebird 1.x. Added here because Promise.defer() is deprecated as of bluebird 2.x */\r\nfunction defer() {\r\n    var resolve, reject;\r\n    var promise = new Promise(function () {\r\n        resolve = arguments[0];\r\n        reject = arguments[1];\r\n    });\r\n    return {\r\n        resolve: resolve,\r\n        reject: reject,\r\n        promise: promise\r\n    };\r\n}\r\nmodule.exports = defer;\r\n//# sourceMappingURL=defer.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/await/index.js":"var makeAwaitFunc = require('./makeAwaitFunc');\r\n/**\r\n  * Suspends a suspendable function until the given awaitable expression produces\r\n  * a result. If the given expression produces an error, then an exception is raised\r\n  * in the suspendable function.\r\n  * @param {any} expr - The awaitable expression whose results are to be awaited.\r\n  * @returns {any} The final result of the given awaitable expression.\r\n  */\r\nvar await = makeAwaitFunc();\r\nawait.in = makeAwaitFunc('in');\r\nawait.top = makeAwaitFunc('top');\r\nmodule.exports = await;\r\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/src/await/makeAwaitFunc.js":"var Fiber = require('../fibers');\r\nvar Promise = require('bluebird');\r\nvar _ = require('lodash');\r\n/** Function for creating a specific variant of the await() function.\r\n *  @param {string} variant - Recognised values: undefined, 'in', 'top'.\r\n */\r\nfunction makeAwaitFunc(variant) {\r\n    // Return an await function tailored to the given options.\r\n    switch (variant) {\r\n        case 'in': return getExtraInfo(traverseInPlace);\r\n        case 'top': return function (n) { return getExtraInfo(traverseInPlace, n); };\r\n        default: return getExtraInfo(traverseClone);\r\n    }\r\n}\r\n/** Helper function for makeAwaitFunc(). */\r\nfunction getExtraInfo(traverse, topN) {\r\n    return function await() {\r\n        // Ensure this function is executing inside a fiber.\r\n        if (!Fiber.current) {\r\n            throw new Error('await functions, yield functions, and value-returning suspendable ' +\r\n                'functions may only be called from inside a suspendable function. ');\r\n        }\r\n        // Parse argument(s). If not a single argument, treat it like an array was passed in.\r\n        if (arguments.length === 1) {\r\n            var expr = arguments[0];\r\n        }\r\n        else {\r\n            expr = new Array(arguments.length);\r\n            for (var i = 0; i < arguments.length; ++i)\r\n                expr[i] = arguments[i];\r\n            traverse = traverseInPlace;\r\n        }\r\n        // Handle each supported 'awaitable' appropriately...\r\n        var fiber = Fiber.current;\r\n        if (expr && _.isFunction(expr.then)) {\r\n            // A promise: resume the coroutine with the resolved value, or throw the rejection value into it.\r\n            // NB: ensure the handlers return null to avoid bluebird 3.x warning 'a promise was created in a\r\n            //     handler but none were returned from it'. This occurs if the next resumption of the suspendable\r\n            //     function (i.e. in the client's code) creates a bluebird 3.x promise and then awaits it.\r\n            expr.then(function (val) { return (fiber.run(val), fiber = null); }, function (err) { return (fiber.throwInto(err), fiber = null); });\r\n        }\r\n        else if (_.isFunction(expr)) {\r\n            // A thunk: resume the coroutine with the callback value, or throw the errback value into it.\r\n            expr(function (err, val) { if (err)\r\n                fiber.throwInto(err);\r\n            else\r\n                fiber.run(val); fiber = null; });\r\n        }\r\n        else if (_.isArray(expr) || _.isPlainObject(expr)) {\r\n            // An array or plain object: resume the coroutine with a deep clone of the array/object,\r\n            // where all contained promises and thunks have been replaced by their resolved values.\r\n            // NB: ensure handlers return null (see similar comment above).\r\n            var trackedPromises = [];\r\n            expr = traverse(expr, trackAndReplaceWithResolvedValue(trackedPromises));\r\n            if (!topN) {\r\n                Promise.all(trackedPromises).then(function (val) { return (fiber.run(expr), fiber = null); }, function (err) { return (fiber.throwInto(err), fiber = null); });\r\n            }\r\n            else {\r\n                Promise.some(trackedPromises, topN).then(function (val) { return (fiber.run(val), fiber = null); }, function (err) { return (fiber.throwInto(err), fiber = null); });\r\n            }\r\n        }\r\n        else {\r\n            // Anything else: resume the coroutine immediately with the value.\r\n            setImmediate(function () { fiber.run(expr); fiber = null; });\r\n        }\r\n        // Suspend the current fiber until the one of the above handlers resumes it again.\r\n        return Fiber.yield();\r\n    };\r\n}\r\n/** In-place (ie non-cloning) object traversal. */\r\nfunction traverseInPlace(o, visitor) {\r\n    if (_.isArray(o)) {\r\n        var len = o.length;\r\n        for (var i = 0; i < len; ++i) {\r\n            traverseInPlace(o[i], visitor);\r\n            visitor(o, i);\r\n        }\r\n    }\r\n    else if (_.isPlainObject(o)) {\r\n        for (var key in o) {\r\n            if (!o.hasOwnProperty(key))\r\n                continue;\r\n            traverseInPlace(o[key], visitor);\r\n            visitor(o, key);\r\n        }\r\n    }\r\n    return o;\r\n}\r\n/** Object traversal with cloning. */\r\nfunction traverseClone(o, visitor) {\r\n    var result;\r\n    if (_.isArray(o)) {\r\n        var len = o.length;\r\n        result = new Array(len);\r\n        for (var i = 0; i < len; ++i) {\r\n            result[i] = traverseClone(o[i], visitor);\r\n            visitor(result, i);\r\n        }\r\n    }\r\n    else if (_.isPlainObject(o)) {\r\n        result = {};\r\n        for (var key in o) {\r\n            if (o.hasOwnProperty(key)) {\r\n                result[key] = traverseClone(o[key], visitor);\r\n                visitor(result, key);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        result = o;\r\n    }\r\n    return result;\r\n}\r\n/** Visitor function factory for handling thunks and promises in awaited object graphs. */\r\nfunction trackAndReplaceWithResolvedValue(tracking) {\r\n    // Return a visitor function closed over the specified tracking array.\r\n    return function (obj, key) {\r\n        // Get the value being visited, and return early if it's falsy.\r\n        var val = obj[key];\r\n        if (!val)\r\n            return;\r\n        // If the value is a thunk, convert it to an equivalent promise.\r\n        if (_.isFunction(val))\r\n            val = thunkToPromise(val);\r\n        // If the value is a promise, add it to the tracking array, and replace it with its value when resolved.\r\n        if (_.isFunction(val.then)) {\r\n            tracking.push(val);\r\n            val.then(function (result) { obj[key] = result; }, function (err) { });\r\n        }\r\n    };\r\n}\r\n/** Convert a thunk to a promise. */\r\nfunction thunkToPromise(thunk) {\r\n    return new Promise(function (resolve, reject) {\r\n        var callback = function (err, val) { return (err ? reject(err) : resolve(val)); };\r\n        thunk(callback);\r\n    });\r\n}\r\nmodule.exports = makeAwaitFunc;\r\n//# sourceMappingURL=makeAwaitFunc.js.map","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/async.js":"ï»¿var async = require('./src/async');\r\nmodule.exports = async;\r\n","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/await.js":"ï»¿var await = require('./src/await');\r\nmodule.exports = await;\r\n","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/comparison/benchmark.js":"var path = require('path');\r\nvar async = require('async'); // NB: async is used here in the benchmarking code, in case co or\r\n                              // asyncawait won't run on the version of node being benchmarked.\r\nvar _ = require('lodash');\r\ntry { var memwatch = require('memwatch'); } catch (ex) { }\r\nvar rewire = require('rewire');\r\n\r\n\r\n// Functions available for benchmarking.\r\nvar functions = {\r\n    countFiles: 'countFiles',\r\n    fibonacci: 'fibonacci',\r\n    largest: 'largest'\r\n\r\n};\r\n\r\n// Variants available for benchmarking.\r\nvar variants = {\r\n    async: 'async',\r\n    asyncawait: 'asyncawait',\r\n    asyncx: 'asyncx',\r\n    bluebird: 'bluebird',\r\n    callbacks: 'callbacks',\r\n    co: 'co',\r\n    synchronous: 'synchronous'\r\n};\r\n\r\n\r\n// ================================================================================\r\n// Benchmark configuration - adjust to suit.\r\n\r\nvar SELECTED_FUNCTION = functions.largest;\r\n\r\nvar SELECTED_VARIANT = variants.asyncawait;\r\n\r\nvar SAMPLES_PER_RUN = 100;   // How many times the function will be called per run.\r\n\r\nvar RUNS_PER_BENCHMARK = 10;  // How many runs make up the whole benchmark.\r\n\r\nvar CONCURRENCY_FACTOR = 10;  // Max number of concurrent invocations of the function.\r\n\r\n// Some additional switches\r\nvar JUST_CHECK_THE_FUNCTION = false;            // If true, just call the function once and display its results.\r\nvar USE_SAME_SYMBOL_FOR_ALL_SAMPLES = true;     // If true, all samples will use the same symbol ('.'). Otherwise, concurrent samples will use distinct symbols.\r\nvar USE_MOCK_FS = false;                         // If true, uses a mocked 'fs' module returning fixed in-memory results.\r\nvar OUTPUT_GC_STATS = true;                     // If true, indicate GC pauses and statistics, and indicate possible memory leaks.\r\nvar OUTPUT_SAMPLES_PER_SEC_SUMMARY = false;     // If true, print all samples/sec numbers at the end, to export for anaysis (eg for charting).\r\n\r\n// ================================================================================\r\n\r\n\r\n// Set up memory diagnostics\r\nvar fullGCs = 0;\r\nvar incrGCs = 0;\r\nvar leaked = 0;\r\nif (OUTPUT_GC_STATS && memwatch) {\r\n    memwatch.on('leak', function(info) {\r\n        leaked += info.growth;\r\n        process.stdout.write(' [LEAK+' + info.growth +'] ');\r\n    });\r\n    memwatch.on('stats', function(stats) {\r\n        fullGCs = stats.num_full_gc;\r\n        incrGCs = stats.num_inc_gc;\r\n        process.stdout.write(' [GC] ');\r\n    });\r\n}\r\n\r\n\r\n// Run the benchmark (or just check the function).\r\nif (JUST_CHECK_THE_FUNCTION) {\r\n    var name = SELECTED_FUNCTION + '-' + SELECTED_VARIANT;\r\n    var sample = createSampleFunction();\r\n    console.log(\"========== CHECKING '\" + name + \"': ==========\");\r\n    sample(function(err, result) {\r\n        console.log(err || result);\r\n        if (OUTPUT_GC_STATS) {\r\n            console.log(\"========== GCs: \" + fullGCs + 'full/' + incrGCs + \"incr ==========\");\r\n            console.log(\"========== Leaked: \" + leaked + \" ==========\");\r\n        }\r\n    });\r\n} else {\r\n    benchmark();\r\n}\r\n\r\n\r\nfunction benchmark() {\r\n    var name = SELECTED_FUNCTION + '-' + SELECTED_VARIANT;\r\n    var sample = createSampleFunction();\r\n    var allSamplesPerSec = [];\r\n    console.log('========== PERFORMING ' + RUNS_PER_BENCHMARK + \" RUNS ON '\" + name + \"': ==========\\n\");\r\n    var times = [];\r\n    async.timesSeries(\r\n        RUNS_PER_BENCHMARK,\r\n        function (n, next) {\r\n            process.stdout.write('RUN ' + (n + 1));\r\n            run(sample, function (err, timing) {\r\n                if (err) {\r\n                    next(err);\r\n                } else {\r\n                    times.push(timing.totalElapsed);\r\n                    allSamplesPerSec.push(SAMPLES_PER_RUN * 1000.0 / timing.totalElapsed);\r\n                    var msg = SAMPLES_PER_RUN\r\n                        + ' samples took '\r\n                        + (timing.totalElapsed / 1000.0)\r\n                        + ' seconds ('\r\n                        + (SAMPLES_PER_RUN * 1000.0 / timing.totalElapsed)\r\n                        + ' samples/sec), average latency per sample: '\r\n                        + timing.perSample\r\n                        + 'ms';\r\n                    if (OUTPUT_GC_STATS) {\r\n                        msg = msg\r\n                            + ', GCs: '\r\n                            + timing.fullGCs\r\n                            + 'full/'\r\n                            + timing.incrGCs\r\n                            + 'incr, leaked: '\r\n                            + timing.leaked;\r\n                    }\r\n                    console.log(msg + '\\n');\r\n                    next();\r\n                }\r\n            });\r\n        },\r\n        function (err) {\r\n            if (err) {\r\n                console.log(err);\r\n                process.exit();\r\n            } else {\r\n                totalTime = _.reduce(times, function (sum, time) { return sum + time; });\r\n                var averageTime = totalTime / RUNS_PER_BENCHMARK;\r\n                    var msg = 'Average time: '\r\n                        + (averageTime / 1000.0)\r\n                        + ' seconds ('\r\n                        + (SAMPLES_PER_RUN * 1000.0 / averageTime)\r\n                        + ' samples/sec)';\r\n                console.log('========== ' + msg + ' ==========');\r\n                if (OUTPUT_GC_STATS) {\r\n                    console.log(\"========== GCs: \" + fullGCs + 'full/' + incrGCs + \"incr ==========\");\r\n                    console.log(\"========== Leaked: \" + leaked + \" ==========\");\r\n                }\r\n                if (OUTPUT_SAMPLES_PER_SEC_SUMMARY) {\r\n                    console.log(\"========== Summary of samples/sec for all runs: ==========\");\r\n                    console.log(allSamplesPerSec.join(', '));\r\n                }\r\n            }\r\n        });\r\n}\r\n\r\n\r\n\r\nfunction run(sample, callback) {\r\n    var chars = USE_SAME_SYMBOL_FOR_ALL_SAMPLES ? '.' : './#$@%^&*+!=-?~`|()[]ABCDEFGHIJKLMNOPQRS';\r\n    var start = new Date().getTime();\r\n    var startFullGCs = fullGCs;\r\n    var startIncrGCs = incrGCs;\r\n    var startLeaked = leaked;\r\n    var sumOfTimePerSample = 0.0;\r\n    async.times(\r\n        CONCURRENCY_FACTOR,\r\n        function (m, nextOuter) {\r\n            var char = chars.charAt(m % chars.length);\r\n            async.timesSeries(\r\n                1.0 * SAMPLES_PER_RUN / CONCURRENCY_FACTOR,\r\n                function (n, nextInner) {\r\n                    process.stdout.write(char);\r\n                    var start = new Date().getTime();\r\n                    sample(function() {\r\n                        var end = new Date().getTime();\r\n                        sumOfTimePerSample += (end - start);\r\n                        nextInner();\r\n                    });\r\n                },\r\n                function (err) {\r\n                    nextOuter(err);\r\n                }\r\n            );\r\n        },\r\n        function(err, res) {\r\n            process.stdout.write('\\n');\r\n            if (err) { callback(err); return; }\r\n            var perSample = sumOfTimePerSample / SAMPLES_PER_RUN;\r\n            var totalElapsed = new Date().getTime() - start;\r\n            callback(null, {\r\n                perSample: perSample,\r\n                totalElapsed: totalElapsed,\r\n                fullGCs: fullGCs - startFullGCs,\r\n                incrGCs: incrGCs - startIncrGCs,\r\n                leaked: leaked - startLeaked\r\n            });\r\n        }\r\n    );\r\n};\r\n\r\n\r\nfunction createSampleFunction() {\r\n    var moduleId = './' + SELECTED_FUNCTION + '/' + SELECTED_FUNCTION + '-' + SELECTED_VARIANT;\r\n    var selectedFunction = rewire(moduleId);\r\n    if (USE_MOCK_FS) selectedFunction.__set__('fs', require('./mockfs'));\r\n    switch (SELECTED_FUNCTION) {\r\n        case functions.countFiles:\r\n            var dirToCheck = path.join(__dirname, '.');\r\n            var sample = function (callback) {\r\n                selectedFunction(dirToCheck, function (err, result) {\r\n                    setImmediate(callback, err, result);\r\n                });\r\n            };\r\n            break;\r\n\r\n        case functions.fibonacci:\r\n            var n = 5;\r\n            var sample = function (callback) {\r\n                selectedFunction(n, function (err, result) {\r\n                    setImmediate(callback, err, result);\r\n                });\r\n            };\r\n            break;\r\n\r\n        case functions.largest:\r\n            var dirToCheck = path.join(__dirname, '.');\r\n            var options = { recurse: true, preview: true };\r\n            var sample = function (callback) {\r\n                selectedFunction(dirToCheck, options, function (err, result) {\r\n                    setImmediate(callback, err, result);\r\n                });\r\n            };\r\n            break;\r\n\r\n    }\r\n    return sample;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-asyncawait/node_modules/asyncawait/comparison/mockfs.js":"ï»¿var mock = require('mock-fs');\r\nvar Promise = require('bluebird');\r\n\r\n\r\nvar config = {\r\n    'mocks/m1': {\r\n        dir11: {\r\n            file111: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\r\n            file112: 'bbbbbbbbbbbbbb',\r\n            file113: 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',\r\n            file114: 'dddddddddddddddddddddddddddddddddddddddd',\r\n            file115: 'eeeeeee',\r\n            file116: 'ffffffffffffffffff',\r\n            file117: 'gggggggggggggggggggggggggggggggggggggggggggggggggggg',\r\n            file118: 'hhhhhhhhhhhhhhhhhhhhhhhhhhh',\r\n            file119: 'iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii',\r\n        },\r\n        dir12: {},\r\n        file11: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\r\n        file12: 'b',\r\n        file13: 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',\r\n    },\r\n    'mocks/m2': {\r\n        file21: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\r\n    },\r\n    'mocks/m3': {\r\n    }\r\n};\r\n\r\n\r\nvar fs = Promise.promisifyAll(mock.fs(config));\r\nmodule.exports = fs;\r\n"}